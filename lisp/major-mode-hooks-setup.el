(defvar yf/major-mode-hooks-dir
  ;; Support for no-littering.el without any interference 
  (if (file-exists-p (concat user-emacs-directory "etc/"))
      (concat user-emacs-directory "etc/major-hooks/")
    (concat user-emacs-directory "major-hooks/"))
  "The directory that is used for major mode configuration files")

(defvar yf/major-mode-hooks--table
  (let ((dir-list (directory-files yf/major-mode-hooks-dir)))
    ;;Weakness determines the garbage collection rate;
    ;;key-and-value requires that both a key and value
    ;;be present in order to avoid garbage collection
    ;;if they are unused in any other context
    (make-hash-table :weakness nil
		     :size (length dir-list)
		     :rehash-size 1.1))
  "The table to keep track of which modes have
files that should be loaded after they open")


(defun yf-major-mode-hooks--populate-table ()
  "Populates `yf/major-mode-hooks--table' with the files in `yf/major-mode-hooks-dir'"
  (cl-flet* ((get-mode-symbol (lambda (filename)
				(intern
				 (file-name-nondirectory
				  (file-name-sans-extension filename)))))
	     (put-hash-hooks-table (lambda (filename)
				     (puthash (get-mode-symbol filename)
					      (file-truename filename)
					      yf/major-mode-hooks--table)))
	     (filter-func-factory
	      (lambda (extension)
		(lambda (filtee) (string= extension (file-name-extension filtee))))))
    (let* ((dir-list (directory-files yf/major-mode-hooks-dir))
	   (el-list (seq-filter (filter-func-factory "el") dir-list))
	   (elc-list (seq-filter (filter-func-factory "elc") dir-list)))
      (mapc 'put-hash-hooks-table el-list)
      (mapc 'put-hash-hooks-table elc-list))))

(defun yf-add-major-hook (requirement hook)
  "Adds requiring REQUIREMENT to HOOK"
  (add-hook hook (lambda () (try-require requirement))))

;; symbol-name converts symbol to string nitwit
(defun yf-edit-major-mode-hook (&optional mode)
  "Edit the hook file for the MODE major mode. 
Current major mode if called by default or
if called interactively

If the file does not already exist, create it, add a
requirement statement to major-mode-hooks.el and 
create the file with a newline followed by an appropriate 
provide statement. 

The files take the form {name of MODE (sans -mode)}-hook.el
in ${yf/major-mode-hooks-dir}/majorHooks

Note that this function does not check for the existance
of require statements in major-mode-hooks.el"
  (interactive (list major-mode))
  (let* ((acting-mode-name (symbol-name mode))
	 (hook-file-symbol-name (concat acting-mode-name "-hook"))
	 (hook-file-symbol-name-file (concat acting-mode-name "-file"))
	 (major-mode-file-dir (file-truename yf/major-mode-hooks-dir))
	 (major-hooks-file (concat major-mode-file-dir "/major-mode-hooks.el"))
	 (hook-file-path (concat major-mode-file-dir "/" hook-file-symbol-name-file ".el")))
    (message major-hooks-file)
    (if (not (file-exists-p major-hooks-file))
	(shell-command (concat
			"echo \";;;;This file was automatically generated by;;;;\\n;;;;major-mode-hooks-setup.el and shouldn't;;;;\\n;;;;need to be edited manually;;;;\\n\\n\\n;;end of major-mode-hooks.el\" > " major-hooks-file) nil nil))
    (if (file-exists-p hook-file-path)
	(find-file hook-file-path)
      ;; create the hook file dir if it doesn't exist
      (if (not (file-exists-p major-mode-file-dir))
	  (make-directory major-mode-file-dir t))
      (let ((major-mode-hooks-buffer
	     ;; This nonesense is here just to check if
	     ;;The buffer is already open, so it can be
	     ;;closed automatically if it wasn't and
	     ;;and left open if it was.
	     (-some (lambda (acting-buffer)
		      (if (string-equal major-mode-file-dir
					(buffer-file-name acting-buffer))
			  acting-buffer))
		    (buffer-list)))
	    (insert-hook-require
	     (lambda ()
	       ;; Two movements as I'm not entirely sure where
	       ;;the cursor will end up after dumping file
	       ;;contents, and I don't want to figure this
	       ;;out. Forward line will never error out so
	       ;;forcing the cursor to move down too much
	       ;;isn't an issue.
	       (forward-line (count-lines (point-max) (point-min)))
	       (forward-line -2)
	       (insert (concat "(add-hook '" hook-file-symbol-name " (lambda () (load-file (concat yf/major-mode-hooks-dir \"" hook-file-symbol-name-file ".el\"))))\n"))
	       ))
	    (current-buffer (buffer-name)))
	(if (not major-mode-hooks-buffer)
	    (with-temp-buffer
	      (insert-file-contents major-hooks-file)
	      (funcall insert-hook-require)
	      ;; To add our new hook in
	      (eval-buffer)
	      (write-file major-hooks-file))
	  (set-buffer (find-file-existing major-hooks-file))
	  (funcall insert-hook-require)
	  (save-buffer)))
      (find-file hook-file-path)
      (insert (concat
	       ";;;;;;;;;;Automatically generated by yf-edit-major-mode-hook;;;;;;;;;;;\n\n\n;;'"
	       hook-file-symbol-name-file ".el ends here"))
      (forward-line -2)
      (save-buffer))))

;;--------------------------------------------------
;;------------Automatically generated---------------
;;-----------DO NOT EDIT BELOW THIS LINE------------
;;--------------------------------------------------

(add-hook 'python-mode-hook (lambda () (require 'python-mode-file)))
(add-hook 'latex-mode-hook (lambda () (require 'latex-mode-file)))
(add-hook 'fundamental-mode-hook (lambda () (require 'fundamental-mode-file)))
(add-hook 'ruby-mode-hook (lambda () (require 'ruby-mode-file)))
(add-hook 'markdown-mode-hook (lambda () (require 'markdown-mode-file)))
(add-hook 'doc-view-mode-hook (lambda () (require 'doc-view-mode-file)))
(add-hook 'org-mode-hook (lambda () (require 'org-mode-file)))

(provide 'major-mode-hooks-setup)
